# Loop

## 概要
Loopノードは、サブグラフを繰り返し実行し、各イテレーションで入力データの一部を処理します。フィードバックループをサポートし、前回の結果を次のイテレーションの入力として使用できます。

- **ノードタイプ**: Subgraph（動的）
- **クラス**: `UPCGLoopSettings`
- **エレメント**: `FPCGLoopElement`

## 機能詳細
このノードは、指定されたサブグラフを複数回実行します。ループピンとフィードバックピンを使用して、要素ごとの反復処理や累積的な処理を実現できます。

### 主な機能
- **要素ごとのループ**: ループピンの各データ要素に対してサブグラフを実行
- **フィードバックループ**: 前のイテレーションの出力を次のイテレーションの入力に使用
- **複数ピンのループ**: 複数のピンを同期してループ処理
- **グラフデフォルト設定**: サブグラフのピン使用設定を自動的に使用
- **手動ピン指定**: カンマ区切りリストでループピンとフィードバックピンを指定

### 処理フロー
1. ループピンとフィードバックピンの名前を取得
2. ループピンのデータをイテレーションごとに分割
3. 各イテレーションで：
   - ループピンから1つの要素を取得
   - フィードバックピンに前回の結果を設定
   - 固定入力ピンのデータを転送
   - サブグラフを実行
4. すべてのイテレーションの結果を収集

## プロパティ

### bUseGraphDefaultPinUsage
- **型**: bool
- **デフォルト値**: true
- **カテゴリ**: Data
- **アクセス**: BlueprintReadWrite, EditAnywhere
- **説明**: trueの場合、ピン使用設定（通常、ループ、フィードバック）をサブグラフから取得します。falseの場合、手動で指定されたリストを使用します

### LoopPins
- **型**: FString
- **カテゴリ**: Data
- **アクセス**: BlueprintReadWrite, EditAnywhere
- **表示条件**: `!bUseGraphDefaultPinUsage`
- **説明**: カンマ区切りのピン名リスト。これらのピンの要素ごとにステップ実行します。複数指定する場合、すべて同じ数のデータを持つ必要があります。指定がない場合、最初に接続されたピンがループピンとして使用されます

### FeedbackPins
- **型**: FString
- **カテゴリ**: Data
- **アクセス**: BlueprintReadWrite, EditAnywhere
- **表示条件**: `!bUseGraphDefaultPinUsage`
- **説明**: カンマ区切りのフィードバックピン名リスト。各イテレーションで、前回のループの同名出力ピンのデータを受け取ります。初期データがある場合、最初のイテレーションでのみ使用されます

### bTokenizeOnWhiteSpace (非推奨)
- **型**: bool
- **デフォルト値**: false
- **カテゴリ**: Settings
- **表示条件**: `bTokenizeOnWhiteSpace`
- **状態**: UE 5.5で非推奨
- **説明**: スペースを区切り文字として使用する古い動作を有効にします。現在の動作に更新するには無効にしてください

## 使用例

### 基本的な要素ごとのループ
```
// 各ポイントに対してサブグラフを実行
SubgraphInstance: [G_ProcessSinglePoint選択]
bUseGraphDefaultPinUsage: true
// サブグラフのInputノードで "Points" ピンをLoopとして設定
結果: 入力ポイントの各要素に対してサブグラフが実行される
```

### フィードバックループによる累積処理
```
// 各イテレーションで結果を累積
SubgraphInstance: [G_AccumulateValues選択]
bUseGraphDefaultPinUsage: true
// サブグラフで:
//   - "Items" ピンをLoopとして設定
//   - "Accumulator" ピンをFeedbackとして設定
結果: 各アイテムを処理し、累積結果を次のイテレーションに渡す
```

### 手動ピン指定によるループ
```
// ピン使用を手動で指定
bUseGraphDefaultPinUsage: false
LoopPins: "InputA,InputB"
FeedbackPins: "Result"
SubgraphInstance: [G_CustomLoop選択]
結果: InputAとInputBを同期してループし、Resultをフィードバック
```

### 連鎖的な処理
```
// 前の結果を次の入力として使用
SubgraphInstance: [G_ChainedProcess選択]
LoopPins: "Steps"
FeedbackPins: "Current"
// 各ステップで前の結果を変換
結果: パイプライン的な連鎖処理
```

### 複数ピンの同期ループ
```
// 複数のデータソースを同時にループ
bUseGraphDefaultPinUsage: false
LoopPins: "Positions,Rotations,Scales"
SubgraphInstance: [G_ApplyTransform選択]
// すべてのピンが同じ要素数を持つ必要がある
結果: 各イテレーションで対応する位置、回転、スケールを処理
```

## 実装の詳細

### 基底クラス
- **Settings**: `UPCGSubgraphSettings`を継承
- **Element**: `FPCGSubgraphElement`を継承

### 入出力ピン
サブグラフのピン設定に基づいて動的に決定：
- **ループピン**: 各イテレーションで1要素ずつ処理
- **フィードバックピン**: 前のイテレーションの出力を受け取る
- **通常のピン**: すべてのイテレーションで同じデータを使用

### 処理の特徴
- **動的グラフ**: `IsDynamicGraph()` が `true` を返すため、実行時に動的に解決されます
- **カスタム入力転送**: `FPCGLoopInputForwardingElement` を使用してフィードバックデータを管理
- **イテレーション管理**: 各イテレーションに対して個別のサブグラフ実行タスクを作成

### ピンアイコン
`GetPinExtraIcon()` により、ループピンとフィードバックピンには特別なアイコンが表示されます。

### データコレクションの準備
`PrepareLoopDataCollections()` メソッドで：
1. ループピンのデータを各イテレーション用に分割
2. フィードバックピンの初期データを準備
3. 固定入力データを保存

### 入力転送要素
`FPCGLoopInputForwardingElement` は、通常の入力転送に加えて、前のイテレーションのタスクからフィードバックデータを取得します。

## パフォーマンス考慮事項

1. **イテレーション数**: ループピンのデータ数が多いほど実行時間が増加します
2. **サブグラフの複雑度**: 各イテレーションでサブグラフが実行されるため、サブグラフの複雑度が直接影響します
3. **フィードバックデータのサイズ**: 大量のフィードバックデータはメモリ使用量を増加させます
4. **並列化の制約**: イテレーションは順次実行されるため、並列化できません
5. **タスク生成コスト**: 各イテレーションに対してタスクが生成されます

## 注意事項

1. **データ数の一致**: 複数のループピンを使用する場合、すべて同じ数のデータ要素を持つ必要があります
2. **フィードバックピンの型**: フィードバックピンの入力型と対応する出力型は一致する必要があります
3. **初期フィードバックデータ**: フィードバックピンに初期データがない場合、最初のイテレーションでは空のデータセットが使用されます
4. **無限ループの防止**: サブグラフが常に同じ出力を生成すると、意図しない動作になる可能性があります
5. **ピン名の正確性**: 手動でピン名を指定する場合、スペルミスに注意してください
6. **カンマの使用**: ピン名リストはカンマで区切ります（スペースは使用しません）

## ループとフィードバックの設計パターン

### 1. マップ操作
各要素に対して同じ変換を適用：
```
LoopPins: "Elements"
// 各要素を個別に処理
```

### 2. リデュース操作
要素を累積して単一の結果に：
```
LoopPins: "Elements"
FeedbackPins: "Accumulator"
// 各要素をアキュムレータに統合
```

### 3. スキャン操作
累積結果の履歴を保持：
```
LoopPins: "Elements"
FeedbackPins: "RunningTotal"
// 各イテレーションで累積結果を更新
```

### 4. 状態機械
前の状態に基づいて次の状態を計算：
```
LoopPins: "Events"
FeedbackPins: "State"
// イベントに応じて状態を遷移
```

### 5. パイプライン処理
データを段階的に変換：
```
LoopPins: "Stages"
FeedbackPins: "Current"
// 各ステージで前の結果を変換
```

## トラブルシューティング

### ループが実行されない
- ループピンにデータが接続されているか確認
- サブグラフが有効か確認
- ピン名が正しいか確認

### フィードバックデータが渡されない
- フィードバックピンの入出力型が一致しているか確認
- サブグラフの出力ピン名がフィードバックピン名と一致しているか確認

### データ数の不一致エラー
- 複数のループピンを使用する場合、すべて同じ要素数を持つか確認

## 関連ノード
- **Subgraph**: 単一のサブグラフ実行
- **Spawn Actor**: アクターごとにサブグラフを実行
- **Input/Output**: サブグラフの入出力を定義
- **Foreach**: 各要素に対して処理を実行（Loopの簡易版）

## 実装ファイル
- **ヘッダー**: `Engine/Plugins/PCG/Source/PCG/Public/Elements/PCGLoopElement.h`
- **実装**: `Engine/Plugins/PCG/Source/PCG/Private/Elements/PCGLoopElement.cpp`
- **基底クラス**: `Engine/Plugins/PCG/Source/PCG/Public/PCGSubgraph.h`
